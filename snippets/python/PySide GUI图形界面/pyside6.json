{
  "引入 PySide6 图形界面库": {
    "prefix": ["import_PySide6", "ipt_PySide6"],
    "body": [
      "import sys",
      "from pathlib import Path",
      "",
      "sys.path.append(str(Path.cwd().resolve()))",
      "",
      "# ! 开发调试时, 导入全部 PySide 模块",
      "from PySide6 import *  # 开发调试时, 全部导入, 解决类型错误问题",
      "from PySide6.QtCore import *  # 开发调试时, 全部导入, 解决类型错误问题",
      "from PySide6.QtGui import *  # 开发调试时, 全部导入, 解决类型错误问题",
      "from PySide6.QtWidgets import *  # 开发调试时, 全部导入, 解决类型错误问题",
      "",
      "# ! 运行|打包时, 按需导入 PySide 模块",
      "import PySide6",
      "from PySide6 import QtCore, QtGui, QtWidgets  # 导入 PySide 模块 三大基础类",
      "from PySide6.QtCore import (",
      "    QDate,",
      "    QObject,",
      "    QThread,  # 线程",
      "    QTimer,  # 定时器, 替代 time.sleep()",
      "    Signal,  # 信号",
      ")",
      "from PySide6.QtGui import (",
      "    QIntValidator,  # 整数输入限制,",
      "    QKeySequence,  # 实例化快捷键按钮对象类句柄,",
      "    QShortcut,  # 实例化快捷键对象类句柄,",
      ")",
      "from PySide6.QtWidgets import (",
      "    QApplication,",
      "    QHeaderView,",
      "    QMessageBox,",
      "    QPushButton,",
      "    QTableWidget,",
      "    QTableWidgetItem,",
      "    QVBoxLayout,",
      "    QWidget,",
      ")",
      "",
      "from ${1:ui_py_Path} import Ui_Form"
    ],
    "description": ["引入 PySide6 图形界面库"]
  },
  "引入 PySide6 图形界面库.tmpl": {
    "prefix": ["import_PySide6=", "ipt_PySide6="],
    "body": [
      "import sys",
      "from pathlib import Path",
      "",
      "sys.path.append(str(Path.cwd().resolve()))",
      "",
      "# ! 开发调试时, 导入全部 PySide 图形界面库模块",
      "from PySide6 import *  # 开发调试时, 全部导入, 解决类型错误问题",
      "from PySide6.QtCore import *  # 开发调试时, 全部导入, 解决类型错误问题",
      "from PySide6.QtGui import *  # 开发调试时, 全部导入, 解决类型错误问题",
      "from PySide6.QtWidgets import *  # 开发调试时, 全部导入, 解决类型错误问题",
      "",
      "# ! 运行|打包时, 按需导入 PySide 图形界面库模块",
      "import PySide6",
      "from PySide6 import QtCore, QtGui, QtWidgets  # 导入 PySide 模块 三大基础类",
      "from PySide6.QtCore import (",
      "    QDate,",
      "    QObject,",
      "    QThread,  # 线程",
      "    QTimer,  # 定时器, 替代 time.sleep()",
      "    Signal,  # 信号",
      ")",
      "from PySide6.QtGui import (",
      "    QIntValidator,  # 整数输入限制,",
      "    QKeySequence,  # 实例化快捷键按钮对象类句柄,",
      "    QShortcut,  # 实例化快捷键对象类句柄,",
      ")",
      "from PySide6.QtWidgets import (",
      "    QApplication,",
      "    QHeaderView,",
      "    QMessageBox,",
      "    QPushButton,",
      "    QTableWidget,",
      "    QTableWidgetItem,",
      "    QVBoxLayout,",
      "    QWidget,",
      ")",
      "",
      "from ${1:ui_py_Path} import Ui_Form",
      "",
      "class MainThread(QObject):",
      "    # ! 信号: 子线程 -> 窗体",
      "    # * 信号 = Signal(类型)",
      "",
      "    def __init__(self) -> None:",
      "        super().__init__()",
      "",
      "",
      "class MainUI(QWidget, Ui_Form):  # 继承 Ui_Form 类的实例",
      "    # ! 信号: 窗体 -> 子线程",
      "    # * 信号 = Signal(类型)",
      "",
      "    def __init__(self) -> None:",
      "        super().__init__()  # 解决多重继承问题, 调用_继承父类 QMainWindow/QWidget 的__init__方法",
      "        self.setupUi(self)  # 传入窗体对象作为参数",
      "        self.autoRun()  # 图形化界面入口函数",
      "        self.bind()  # 界面绑定函数",
      "    # * 窗体启动自动执行函数",
      "    def autoRun(self):",
      "        pass",
      "    def bind(self):",
      "        pass",
      "if __name__ == \"__main__\":",
      "    app = QApplication(sys.argv)  # 创建应用程序对象, 传入命令行参数",
      "    main_ui = MainUI()",
      "    main_ui.show()",
      "    # 程序运行, sys.exit方法确保主循环安全结束, 释放资源",
      "    sys.exit(app.exec())  # 使用Jupyter进行测试时, 直接使用 app.exec()"
    ],
    "description": ["引入 PySide6 图形界面库.tmpl"]
  },
  "PySide6.MainUI 创建窗体对象": {
    "prefix": ["PySide6_QWidget="],
    "body": [
      "class MainUI(QWidget, Ui_Form):  # 继承 Ui_Form 类的实例",
      "    # ! 信号: 窗体 -> 子线程",
      "    # * 信号 = Signal(类型)",
      "",
      "    def __init__(self) -> None:",
      "        super().__init__()  # 解决多重继承问题, 调用_继承父类 QMainWindow/QWidget 的__init__方法",
      "        self.setupUi(self)  # 传入窗体对象作为参数",
      "        self.autoRun()  # 图形化界面入口函数",
      "        self.bind()  # 界面绑定函数",
      "    # * 窗体启动自动执行函数",
      "    def autoRun(self):",
      "        pass",
      "    def bind(self):",
      "        pass"
    ],
    "description": ["PySide6.MainUI 创建窗体对象"]
  },
  "PySide6.MainUI.createQThread 窗体创建子线程对象": {
    "prefix": ["PySide6_createQThread="],
    "body": [
      "def createThread(self):",
      "    \"\"\"",
      "    创建 子线程",
      "    .emit(传递的参数为函数的默认[第一个]参数)",
      "    \"\"\"",
      "    # 创建一个线程和一个工作实例",
      "    self.work_thread = QThread()  # 创建QThread子线程实例",
      "    self.work = MainThread()  # 创建子线程工作实例",
      "    # ! 子线程信号 -> 窗体函数(槽) 绑定",
      "    # * self.work.子线程信号.connect(self.窗体函数)",
      "    # todo Thread线程示例: ",
      "",
      "    # ! 窗体信号 -> 子线程函数(槽) 绑定",
      "    # * self.窗体信号.connect(self.work.子线程(槽)函数)",
      "    # todo 窗体Signal: ",
      "",
      "    # 子线程工作实例 -moveToThread(移动到)-> QThread线程实例",
      "    self.work.moveToThread(self.work_thread)",
      "    # 启动QThread子线程",
      "    self.work_thread.start()",
      "    self.work_thread.started.connect(lambda: print(\"子线程_启动\"))  # 启动子线程工作",
      "    self.work_thread.finished.connect(lambda: print(\"子线程_结束\"))  # 结束子线程工作",
      "",
      "def closeEvent(self, event):",
      "    \"\"\"",
      "    重新定义窗体关闭事件, 加入确认关闭提示, 并结束子线程",
      "    Args:",
      "        event (QCloseEvent): 继承QCloseEvent窗体关闭事件",
      "    \"\"\"",
      "    result = QtWidgets.QMessageBox.question(",
      "    self,",
      "    \"正在关闭程序\",  # [QMessageBox标题]",
      "    \"亲@你确定想关闭我?别后悔!!! '_'\",  # [QMessageBox窗体内容]",
      "    QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,  # [QMessageBox窗体按钮]",
      "    match result:",
      "        case QtWidgets.QMessageBox.Yes:",
      "            # comment: 点击 Yes 确认结束子线程和主线程",
      "            # * self.QThread实例对象.terminate()  # 中断子线程",
      "            # * self.QThread实例对象.deleteLater()  # 删除子线程实例对象",
      "            # * self.QThread实例对象.quit()  # 结束子线程",
      "            event.accept()  # 接受关闭事件, 结束主线程",
      "        case _:",
      "            # comment: 点击 No 关闭提示, 忽略关闭事件, 继续运行线程",
      "            event.ignore()"
    ],
    "description": ["PySide6.MainUI.createQThread 窗体创建子线程对象"]
  },
  "PySide6.MainUI.closeEvent 重写窗体关闭事件": {
    "prefix": ["PySide6_closeEvent="],
    "body": [
      "def closeEvent(self, event):",
      "    \"\"\"",
      "    重新定义窗体关闭事件, 加入确认关闭提示, 并结束子线程",
      "    Args:",
      "        event (QCloseEvent): 继承QCloseEvent窗体关闭事件",
      "        # * self.QThread实例对象.terminate()  # 中断子线程",
      "        # * self.QThread实例对象.deleteLater()  # 删除子线程实例对象",
      "        # * self.QThread实例对象.quit()  # 结束子线程",
      "    \"\"\"",
      "    replay = QMessageBox.question(",
      "        self,",
      "        \"正在关闭程序\",  # QMessageBox标题",
      "        \"亲@你确定想关闭我?别后悔!!! '_'\",  # QMessageBox窗体内容",
      "        QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,  # QMessageBox窗体按钮组",
      "        QMessageBox.StandardButton.Yes,  # 默认按钮",
      "    )  # [QMessageBox窗体按钮]",
      "    if reply == QMessageBox.Yes:",
      "        # comment: 点击 Yes 确认结束子线程和主线程",
      "        # todo 其他操作",
      "",
      "        event.accept()  # 接受关闭事件, 结束主线程",
      "    else:",
      "        # comment: 点击 No 关闭提示, 忽略关闭事件, 继续运行线程",
      "        event.ignore()"
    ],
    "description": ["PySide6.MainUI.closeEvent 重写窗体关闭事件"]
  },
  "PySide6.MainThread 创建子线程对象": {
    "prefix": ["PySide6_add_classQWidget="],
    "body": [
      "class MainThread(QObject):",
      "    # * 信号: 子线程 -> 窗体",
      "    # * 信号 = Signal(类型)",
      "",
      "    def __init__(self) -> None:",
      "        super().__init__()"
    ],
    "description": ["PySide6.MainUI 创建窗体对象"]
  },
  "PySide6.QApplication 运行窗口": {
    "prefix": ["PySide6_QT_if_main_UI="],
    "body": [
      "if __name__ == \"__main__\":",
      "    app = QApplication(sys.argv)  # 创建应用程序对象, 传入命令行参数",
      "    main_ui = MainUI()",
      "    main_ui.show()",
      "    # 程序运行, sys.exit方法确保主循环安全结束, 释放资源",
      "    sys.exit(app.exec())  # 使用Jupyter进行测试时, 直接使用 app.exec()"
    ],
    "description": ["PySide6.QApplication 运行窗口"]
  },
  "PySide6.QThread.terminate 中断子线程": {
    "prefix": ["PySide6_terminate"],
    "body": [".terminate()"],
    "description": ["PySide6.QThread.terminate 中断子线程"]
  },
  "PySide6.QtGui.QKeySequence:QShortcut 设置快捷键": {
    "prefix": ["PySide6_createQShortcut=QKeySequence="],
    "body": [
      "# * 定义快捷键",
      "def setupShortcutKey(self):",
      "    \"\"\"",
      "    设置快捷键",
      "    \"\"\"",
      "    # * self.快捷键 = QShortcut(QKeySequence(\"按键\"), self)",
      "    # * self.快捷键.activated.connect(self.函数)",
      "    $0",
      "    pass"
    ],
    "description": ["PySide6.QtGui.QKeySequence:QShortcut 设置快捷键"]
  },
  "PySide6.QtWidgets.QTableWidget 导入DataFrame数据": {
    "prefix": ["PySide6_load_DataFrame=add_tableButton="],
    "body": [
      "# * Class Function: 导入DataFrame -> QTableWidget表格数据",
      "def loading_DF(self, data: DataFrame, qtable: QTableWidget):",
      "    \"\"\"",
      "    导入DataFrame -> QTableWidget表格数据",
      "    Args:",
      "        data (DataFrame): DataFrame 数据, 可以是加载CSV文件的csv数据",
      "        qtable (QTableWidget): QTableWidget表格控件",
      "    \"\"\"",
      "    # 清空表格内容",
      "    qtable.clearContents()",
      "    # 设置表头伸缩样式->适应窗口大小",
      "    qtable.horizontalHeader().setSectionResizeMode(",
      "        QHeaderView.ResizeMode.Stretch",
      "    )",
      "    # 获取DataFrame的列名",
      "    columns = data.columns.to_list()",
      "    # 在最后一列添加['操作']",
      "    columns.append(\"操作\")",
      "    # 设置QTableWidget列数和行数",
      "    qtable.setColumnCount(len(columns))",
      "    qtable.setRowCount(data.shape[0])  # .shape -> (行, 列)",
      "    # 填充表头(列名)",
      "    qtable.setHorizontalHeaderLabels(columns)",
      "    # * 设置QTableWidget表格点击反馈",
      "    qtable.cellClicked.connect(lambda row, col: print(f\"{row}行:{col}列\"))",
      "    qtable.itemClicked.connect(lambda item: print(f\"{item.row()}行:{item.column()}列 -> {item.text()}\"))",
      "    # 填充DataFrame数据",
      "    import numpy as np",
      "    data_content = np.array(data).tolist()",
      "    for row_index, row_content in enumerate(data_content):",
      "        for column_index, column_content in enumerate(row_content):",
      "            column_content = str(column_content)",
      "            qtable.setItem(",
      "                row_index, column_index, QTableWidgetItem(column_content)",
      "            )",
      "        # 在每一行的最后一列添加 按钮",
      "        table_button = QPushButton(\"按钮\")",
      "        qtable.setCellWidget(",
      "            row_index, qtable.columnCount() - 1, table_button",
      "        )",
      "        # 点击 按钮 事件绑定 (绑定事件不需要传参, 通过 self.sender() 获取点击的按钮)",
      "        table_button.clicked.connect(self.qtable_button)",
      "",
      "# * Class Function: QTableWidget表格按钮点击事件",
      "def qtable_button(self):",
      "    # * 获取点击按钮信号的发送对象",
      "    btn = self.sender()",
      "    # * 获取点击按钮信号发送对象的坐标",
      "    btn_pos = btn.pos()",
      "    # 获取点击按钮的行和列",
      "    btn_row = self._QTableWidget.indexAt(btn_pos).row()",
      "    btn_col = self._QTableWidget.indexAt(btn_pos).column()",
      "    btn_value = self._QTableWidget.item(btn_row, btn_col).text()",
      "    print(f\"Button clicked in cell ({btn_row}, {btn_col}), cell value: {btn_value}\")",
      ""
    ],
    "description": ["PySide6.QtWidgets.QTableWidget 导入DataFrame数据"]
  },
  "PySide6.QtCore.QTimer 定时器": {
    "prefix": ["PySide6_createTimer="],
    "body": [
      "# * Class Function: 创建定时器",
      "def createTimer(self):",
      "    self.timer = QTimer()",
      "    # 定时监测登录情况(单位: 毫秒, 1秒 = 1000毫秒)",
      "    wait_time = 1000",
      "    self.timer.start(wait_time)",
      "    # self.timer.timeout.connect(lambda)"
    ],
    "description": "PySide6.QtCore.QTimer 定时器"
  },
  "PySide6.sender().pos 获取点击按钮坐标位置": {
    "prefix": ["PySide6_pos"],
    "body": [".pos()"],
    "description": ["PySide6.sender().pos 获取点击按钮坐标位置"]
  }
}
